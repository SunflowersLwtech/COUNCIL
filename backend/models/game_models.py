"""Pydantic models for COUNCIL game entities.

All fields have defaults and validators to handle LLM output variations,
following the same resilient pattern as findings.py.
"""

import json
import uuid
from typing import Any, Literal, Optional
from pydantic import BaseModel, Field, field_validator


class WorldModel(BaseModel):
    """World extracted from uploaded document."""

    title: str = ""
    setting: str = ""
    factions: list[dict] = Field(default_factory=list)
    roles: list[dict] = Field(default_factory=list)
    win_conditions: list[dict] = Field(default_factory=list)
    phases: list[dict] = Field(default_factory=list)
    flavor_text: str = ""

    @field_validator("title", "setting", "flavor_text", mode="before")
    @classmethod
    def coerce_str(cls, v: Any) -> str:
        if v is None:
            return ""
        if isinstance(v, dict):
            return json.dumps(v)
        if isinstance(v, list):
            return "; ".join(str(x) for x in v)
        return str(v)

    @field_validator("factions", "roles", "win_conditions", "phases", mode="before")
    @classmethod
    def coerce_list_of_dicts(cls, v: Any) -> list[dict]:
        if v is None:
            return []
        if isinstance(v, str):
            try:
                parsed = json.loads(v)
                if isinstance(parsed, list):
                    return parsed
                if isinstance(parsed, dict):
                    return [parsed]
            except (json.JSONDecodeError, ValueError):
                return [{"name": v}]
        if isinstance(v, dict):
            # LLM might return {name: details} mapping instead of list
            items = []
            for key, val in v.items():
                if isinstance(val, dict):
                    val["name"] = val.get("name", key)
                    items.append(val)
                elif isinstance(val, str):
                    items.append({"name": key, "description": val})
                elif isinstance(val, list):
                    items.extend(val)
            return items
        if isinstance(v, list):
            result = []
            for item in v:
                if isinstance(item, dict):
                    result.append(item)
                elif isinstance(item, str):
                    result.append({"name": item})
                else:
                    result.append({"name": str(item)})
            return result
        return []


class EmotionalState(BaseModel):
    """6-dimensional emotional state for a character."""

    happiness: float = 0.5
    anger: float = 0.0
    fear: float = 0.1
    trust: float = 0.5
    energy: float = 0.8
    curiosity: float = 0.5


class SimsTraits(BaseModel):
    """Sims-style behavioral tendencies (0-10 scale, 25-point budget)."""
    neat: int = 5
    outgoing: int = 5
    active: int = 5
    playful: int = 5
    nice: int = 5


class MindMirrorPlane(BaseModel):
    """A single Leary thought plane. Scale 0-7, sparse storage."""
    traits: dict[str, int] = Field(default_factory=dict)
    jazz: dict[str, str] = Field(default_factory=dict)

    @field_validator("traits", "jazz", mode="before")
    @classmethod
    def coerce_dict(cls, v: Any) -> dict:
        if v is None:
            return {}
        if isinstance(v, dict):
            return v
        return {}


class MindMirror(BaseModel):
    """Leary's Four Thought Planes for interpersonal style."""
    bio_energy: MindMirrorPlane = Field(default_factory=MindMirrorPlane)
    emotional: MindMirrorPlane = Field(default_factory=MindMirrorPlane)
    mental: MindMirrorPlane = Field(default_factory=MindMirrorPlane)
    social: MindMirrorPlane = Field(default_factory=MindMirrorPlane)


class Relationship(BaseModel):
    """Per-character relationship state."""
    target_id: str = ""
    target_name: str = ""
    closeness: float = 0.0
    trust: float = 0.5
    narrative: str = ""


class Memory(BaseModel):
    """A mood-affecting memory from gameplay."""
    event: str = ""
    mood_effect: dict[str, float] = Field(default_factory=dict)
    narrative: str = ""
    round: int = 0


class Character(BaseModel):
    """A game character with public + hidden layers."""

    id: str = Field(default_factory=lambda: str(uuid.uuid4())[:8])
    # Public layer
    name: str = ""
    persona: str = ""
    speaking_style: str = ""
    avatar_seed: str = ""
    public_role: str = ""
    # Hidden layer
    hidden_role: str = ""
    faction: str = ""
    win_condition: str = ""
    hidden_knowledge: list[str] = Field(default_factory=list)
    behavioral_rules: list[str] = Field(default_factory=list)
    # Personality traits (generated by LLM)
    big_five: str = ""
    mbti: str = ""
    moral_values: list[str] = Field(default_factory=list)
    decision_making_style: str = ""
    secret: str = ""
    # Voice
    voice_id: str = "Sarah"
    # State
    is_eliminated: bool = False
    emotional_state: EmotionalState = Field(default_factory=EmotionalState)
    # Enhanced personality (mind-mirror + sims)
    sims_traits: SimsTraits = Field(default_factory=SimsTraits)
    mind_mirror: MindMirror = Field(default_factory=MindMirror)
    # Dynamic state layers
    relationships: list[Relationship] = Field(default_factory=list)
    recent_memories: list[Memory] = Field(default_factory=list)
    # Quick-reference summaries
    personality_summary: str = ""
    current_mood: str = ""
    driving_need: str = ""
    # Motivation layer (from game-facilitator NPC-gen)
    want: str = ""
    method: str = ""

    @field_validator("name", "persona", "speaking_style", "avatar_seed",
                     "public_role", "hidden_role", "faction", "win_condition",
                     "voice_id", "big_five", "mbti", "decision_making_style",
                     "secret", "personality_summary", "current_mood",
                     "driving_need", "want", "method", mode="before")
    @classmethod
    def coerce_str(cls, v: Any) -> str:
        if v is None:
            return ""
        if isinstance(v, dict):
            return json.dumps(v)
        if isinstance(v, list):
            return "; ".join(str(x) for x in v)
        return str(v)

    @field_validator("hidden_knowledge", "behavioral_rules", "moral_values", mode="before")
    @classmethod
    def coerce_str_list(cls, v: Any) -> list[str]:
        if v is None:
            return []
        if isinstance(v, str):
            return [v]
        if isinstance(v, dict):
            return [f"{k}: {val}" for k, val in v.items()]
        if isinstance(v, list):
            return [str(x) for x in v]
        return []


class CharacterPublicInfo(BaseModel):
    """Public projection of Character - strips hidden fields."""

    id: str = ""
    name: str = ""
    persona: str = ""
    speaking_style: str = ""
    avatar_seed: str = ""
    public_role: str = ""
    voice_id: str = ""
    is_eliminated: bool = False


class ChatMessage(BaseModel):
    speaker_id: str = ""
    speaker_name: str = ""
    content: str = ""
    is_public: bool = True
    phase: str = ""
    round: int = 0

    @field_validator("speaker_id", "speaker_name", "content", "phase", mode="before")
    @classmethod
    def coerce_str(cls, v: Any) -> str:
        if v is None:
            return ""
        return str(v)


class VoteRecord(BaseModel):
    voter_id: str = ""
    voter_name: str = ""
    target_id: str = ""
    target_name: str = ""

    @field_validator("voter_id", "voter_name", "target_id", "target_name", mode="before")
    @classmethod
    def coerce_str(cls, v: Any) -> str:
        if v is None:
            return ""
        return str(v)


class VoteResult(BaseModel):
    votes: list[VoteRecord] = Field(default_factory=list)
    tally: dict[str, int] = Field(default_factory=dict)
    eliminated_id: str | None = None
    eliminated_name: str | None = None
    is_tie: bool = False


class NightAction(BaseModel):
    """A night-phase action taken by a character."""
    character_id: str = ""
    action_type: str = ""  # "kill", "investigate", "protect"
    target_id: str | None = None
    result: str = ""

    @field_validator("character_id", "action_type", "result", mode="before")
    @classmethod
    def coerce_str(cls, v: Any) -> str:
        if v is None:
            return ""
        return str(v)


class GameEvent(BaseModel):
    """A dynamic game event (complication, revelation, etc.)."""
    event_type: str = ""  # "complication", "revelation", "time_pressure", "betrayal"
    description: str = ""
    round: int = 0
    injected_at_message: int = 0


class PlayerRole(BaseModel):
    """The human player's hidden role assignment."""
    hidden_role: str = ""           # "Werewolf", "Seer", "Doctor", "Villager"
    faction: str = ""               # "Werewolf", "Village"
    win_condition: str = ""
    is_eliminated: bool = False
    eliminated_by: str = ""         # "vote" | "night_kill" | ""
    allies: list[str] = Field(default_factory=list)  # char IDs of same-faction members (for wolves)


class PlayerNightActionRequest(BaseModel):
    action_type: str = ""           # "kill", "investigate", "protect"
    target_character_id: str = ""


class GameState(BaseModel):
    session_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    phase: Literal["lobby", "discussion", "voting", "reveal", "night", "ended"] = "lobby"
    round: int = 1
    world: WorldModel = Field(default_factory=WorldModel)
    characters: list[Character] = Field(default_factory=list)
    eliminated: list[str] = Field(default_factory=list)
    messages: list[ChatMessage] = Field(default_factory=list)
    votes: list[VoteRecord] = Field(default_factory=list)
    vote_results: list[VoteResult] = Field(default_factory=list)
    night_actions: list[NightAction] = Field(default_factory=list)
    winner: str | None = None
    # Tension & pacing
    tension_level: float = 0.3
    game_events: list[GameEvent] = Field(default_factory=list)
    # Canon tracking (established facts that should not be contradicted)
    canon_facts: list[str] = Field(default_factory=list)
    # Active skill IDs for this game session
    active_skills: list[str] = Field(default_factory=list)
    # Player hidden role
    player_role: PlayerRole | None = None
    # Night phase: waiting for player action before resolving
    awaiting_player_night_action: bool = False


class GameCreateResponse(BaseModel):
    session_id: str = ""
    world_title: str = ""
    world_setting: str = ""
    characters: list[CharacterPublicInfo] = Field(default_factory=list)
    phase: str = "lobby"


class GameChatRequest(BaseModel):
    message: str = ""
    target_character_id: str | None = None


class GameVoteRequest(BaseModel):
    target_character_id: str = ""
